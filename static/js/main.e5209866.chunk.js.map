{"version":3,"sources":["redux/models.ts","redux/utilities.ts","redux/actions.ts","Cell.tsx","redux/selectors.ts","App.tsx","redux/rootReducer.ts","index.tsx"],"names":["MarkerType","GameMode","createAction","type","payload","markCellActionType","restartGameActionType","changeGameActionType","mapDispatchToProps","markCell","rowIndex","columnIndex","connect","state","board","props","className","onClick","cell","markerType","cross","selectAllCellsMarked","createSelector","map","row","filter","flat","length","renderCell","uuid","renderRow","restartGame","changeGame","gameMode","isWinner","currentTurnMarkerType","currentGame","currentGameMode","checkAllCellsMarked","restart","convertGameModeToText","toString","onChange","e","value","currentTarget","parseInt","ticTacToe","gomoku1","gomoku2","message","zero","closable","getGameConfiguration","boardDimension","winningSequenceLength","Error","createBoard","gameConfiguration","initialState","countRowSideSequentCells","currentIndex","step","count","i","countColumnSideSequentCells","currentRowIndex","currentColumnIndex","countDiagonalSideSequentCells","step1","step2","j","isWinningSequence","countColumnSequentCells","countRightDiagonalSequentCells","countLeftDiagonalSequentCells","currentCell","createState","copyBoard","store","createStore","action","newBoard","newState","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.e5209866.chunk.js","sourcesContent":["export enum MarkerType {\r\n    cross,\r\n    zero\r\n}\r\n\r\nexport enum GameMode {\r\n    ticTacToe,\r\n    gomoku1,\r\n    gomoku2\r\n}\r\n\r\nexport interface ICell {\r\n    markerType: MarkerType | null,\r\n    rowIndex: number,\r\n    columnIndex: number\r\n}\r\n\r\nexport interface GameConfiguration {\r\n    boardDimension: number,\r\n    winningSequenceLength: number\r\n}\r\n\r\nexport interface IState {\r\n    board: ICell[][],\r\n    currentTurnMarkerType: MarkerType,\r\n    isWinner: boolean,\r\n    currentGameMode: GameMode,\r\n    gameConfiguration: GameConfiguration\r\n}\r\n","export function createAction<T extends string>(type: T): { type: T };\r\n\r\nexport function createAction<T extends string, P extends any>(type: T, payload: P): { type: T; payload: P };\r\n\r\nexport function createAction(type: string, payload?: any) {\r\n    return { type, payload };\r\n}\r\n","import {createAction} from \"./utilities\";\r\nimport {GameMode} from \"./models\";\r\n\r\nexport const markCellActionType = 'MARK_CELL';\r\nexport const restartGameActionType = 'RESTART_GAME';\r\nexport const changeGameActionType = 'CHANGE_GAME';\r\n\r\nexport const createMarkCellAction = (rowIndex: number, columnIndex: number) => {\r\n    return createAction(markCellActionType, {rowIndex, columnIndex});\r\n};\r\n\r\nexport const createRestartGameAction = () => {\r\n    return createAction(restartGameActionType);\r\n};\r\n\r\nexport const createChangeGameAction = (gameMode: GameMode) => {\r\n    return createAction(changeGameActionType, {gameMode: gameMode});\r\n};\r\n","import React from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {ICell, IState, MarkerType} from \"./redux/models\";\r\nimport './app.css';\r\nimport './cell.css';\r\nimport {createMarkCellAction} from \"./redux/actions\";\r\n\r\ntype Props = ReturnType<typeof mapStateToProps> & typeof mapDispatchToProps & { cell: ICell };\r\n\r\nconst Cell: React.FC<Props> = (props) => {\r\n    const markCell = (): void => {\r\n        props.markCell(props.cell.rowIndex, props.cell.columnIndex);\r\n    };\r\n\r\n    function renderCell() {\r\n        if (props.cell.markerType === null)\r\n            return null;\r\n        return props.cell.markerType === MarkerType.cross ? 'X' : '0';\r\n    }\r\n\r\n    return (\r\n        <span className=\"initialCell\"\r\n              onClick={markCell}>\r\n            {renderCell()}\r\n        </span>\r\n    );\r\n};\r\n\r\nconst mapStateToProps = (state: IState) => ({\r\n    board: state.board\r\n});\r\n\r\nconst mapDispatchToProps = {\r\n    markCell: createMarkCellAction\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Cell);\r\n","import {ICell, IState} from \"./models\";\r\nimport {createSelector} from \"reselect\";\r\n\r\nconst selectBoard = (state: IState): ICell[][] => state.board;\r\n\r\nfunction checkAllCellsMarked(board: ICell[][]): boolean {\r\n    const markedCells = board\r\n        .map(row => row.filter(cell => cell.markerType === null))\r\n        .flat();\r\n    return markedCells.length === 0;\r\n}\r\n\r\nexport const selectAllCellsMarked = createSelector(\r\n    [selectBoard],\r\n    checkAllCellsMarked);","import React from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {GameMode, ICell, IState, MarkerType} from \"./redux/models\";\r\nimport {v4 as uuid} from 'uuid';\r\nimport Cell from \"./Cell\";\r\nimport './app.css';\r\nimport {Alert} from \"antd\";\r\nimport 'antd/dist/antd.css';\r\nimport {createChangeGameAction, createRestartGameAction} from \"./redux/actions\";\r\nimport {selectAllCellsMarked} from \"./redux/selectors\";\r\n\r\ntype Props = ReturnType<typeof mapStateToProps> & typeof mapDispatchToProps;\r\n\r\nconst renderCell = (cell: ICell): JSX.Element =>\r\n    <Cell key={uuid()} cell={cell}/>;\r\n\r\nconst renderRow = (row: ICell[]) =>\r\n    <div key={uuid()}>{row.map(renderCell)}</div>;\r\n\r\nconst App: React.FC<Props> = (props) => {\r\n    function restart() {\r\n        props.restartGame();\r\n    }\r\n\r\n    function changeGame(e: React.FormEvent<HTMLSelectElement>) {\r\n        props.changeGame(parseGameMode(e.currentTarget.value));\r\n    }\r\n\r\n    const defineWinner = () => {\r\n        if (props.isWinner && props.currentTurnMarkerType === MarkerType.zero)\r\n            return \"0\";\r\n        else return \"X\";\r\n    };\r\n\r\n    const showCongratulationsMessage = (): JSX.Element =>\r\n        <Alert message={`${defineWinner()} WON!`}\r\n               type=\"success\"\r\n               closable\r\n               onClick={restart}/>;\r\n\r\n    function renderDrawMessage(): JSX.Element | null {\r\n        if (!props.checkAllCellsMarked || props.isWinner)\r\n            return null;\r\n\r\n        return (\r\n            <Alert message=\"DRAW\"\r\n                   type=\"success\"\r\n                   closable\r\n                   onClick={restart}/>\r\n        )\r\n    }\r\n\r\n    function renderCurrentGameName() {\r\n        return props.currentGame === 0 ? \"TIC TAC TOE\" : \"GOMOKU\";\r\n    }\r\n\r\n    function showTurn() {\r\n        if (props.currentTurnMarkerType === MarkerType.cross)\r\n            return \"X\";\r\n        return \"0\";\r\n    }\r\n\r\n    function convertGameModeToText(gameMode: GameMode): string {\r\n        return gameMode.toString();\r\n    }\r\n\r\n    function parseGameMode(value: string): GameMode {\r\n        return parseInt(value);\r\n    }\r\n\r\n    return (\r\n        <div className=\"app\">\r\n            <table className=\"center\">\r\n                <tbody>\r\n                <tr>\r\n                    <td>\r\n                        <h1>{renderCurrentGameName()}</h1>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td>\r\n                        <span>Game Type </span>\r\n                        <select onChange={changeGame}>\r\n                            <option value={convertGameModeToText(GameMode.ticTacToe)}>TIC TAC TOE</option>\r\n                            <option value={convertGameModeToText(GameMode.gomoku1)}>GOMOKU 10 x 10</option>\r\n                            <option value={convertGameModeToText(GameMode.gomoku2)}>GOMOKU 20 x 20</option>\r\n                        </select>\r\n                        <button onClick={restart}>Restart</button>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td>Current Turn: {showTurn()}</td>\r\n                </tr>\r\n                </tbody>\r\n            </table>\r\n            {props.board.map(renderRow)}\r\n            {props.isWinner && showCongratulationsMessage()}\r\n            {renderDrawMessage()}\r\n        </div>\r\n    );\r\n};\r\n\r\nconst mapStateToProps = (state: IState) => ({\r\n    board: state.board,\r\n    isWinner: state.isWinner,\r\n    currentTurnMarkerType: state.currentTurnMarkerType,\r\n    currentGame: state.currentGameMode,\r\n    checkAllCellsMarked: selectAllCellsMarked(state)\r\n});\r\n\r\nconst mapDispatchToProps = {\r\n    restartGame: createRestartGameAction,\r\n    changeGame: createChangeGameAction\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\r\n","import {GameConfiguration, GameMode, ICell, IState, MarkerType} from \"./models\";\r\nimport {\r\n    createChangeGameAction,\r\n    createMarkCellAction,\r\n    createRestartGameAction,\r\n    changeGameActionType,\r\n    markCellActionType,\r\n    restartGameActionType\r\n} from \"./actions\";\r\n\r\nfunction getGameConfiguration(gameMode: GameMode): GameConfiguration {\r\n    switch (gameMode) {\r\n        case GameMode.ticTacToe:\r\n            return {\r\n                boardDimension: 3,\r\n                winningSequenceLength: 3\r\n            };\r\n        case GameMode.gomoku1:\r\n            return {\r\n                boardDimension: 10,\r\n                winningSequenceLength: 5\r\n            };\r\n        case GameMode.gomoku2:\r\n            return {\r\n                boardDimension: 20,\r\n                winningSequenceLength: 5\r\n            };\r\n    }\r\n    throw new Error(\"Invalid value.\");\r\n}\r\n\r\nfunction createBoard(gameMode: GameMode): ICell[][] {\r\n    const gameConfiguration = getGameConfiguration(gameMode);\r\n\r\n    const board: ICell[][] = [];\r\n\r\n    for (let rowIndex = 0; rowIndex < gameConfiguration.boardDimension; rowIndex++) {\r\n        board[rowIndex] = [];\r\n        for (let columnIndex = 0; columnIndex < gameConfiguration.boardDimension; columnIndex++) {\r\n            const cell: ICell = {\r\n                markerType: null,\r\n                rowIndex,\r\n                columnIndex\r\n            };\r\n            board[rowIndex][columnIndex] = cell;\r\n        }\r\n    }\r\n    return board;\r\n}\r\n\r\nconst initialState: IState = {\r\n    board: createBoard(GameMode.ticTacToe),\r\n    currentTurnMarkerType: MarkerType.cross,\r\n    isWinner: false,\r\n    currentGameMode: GameMode.ticTacToe,\r\n    gameConfiguration: getGameConfiguration(GameMode.ticTacToe)\r\n};\r\n\r\nfunction countRowSideSequentCells(row: ICell[], currentIndex: number, step: number): number {\r\n    const markerType = row[currentIndex].markerType;\r\n    let count = 0;\r\n\r\n    for (let i = currentIndex + step; i >= 0 && i < row.length; i += step) {\r\n        if (row[i].markerType !== markerType)\r\n            return count;\r\n        count++;\r\n    }\r\n    return count;\r\n}\r\n\r\nfunction countColumnSideSequentCells(board: ICell[][], currentRowIndex: number, currentColumnIndex: number, step: number): number {\r\n    const markerType = board[currentRowIndex][currentColumnIndex].markerType;\r\n    let count = 0;\r\n\r\n    for (let i = currentRowIndex + step; i >= 0 && i < board.length; i += step) {\r\n        if (board[i][currentColumnIndex].markerType !== markerType)\r\n            return count;\r\n        count++;\r\n    }\r\n\r\n    return count;\r\n}\r\n\r\nfunction countDiagonalSideSequentCells(board: ICell[][], currentRowIndex: number, currentColumnIndex: number, step1: number, step2: number): number {\r\n    const markerType = board[currentRowIndex][currentColumnIndex].markerType;\r\n    let count = 0;\r\n\r\n    for (let i = currentRowIndex + step1, j = currentColumnIndex + step2; i >= 0 && i < board.length && j >= 0 && j < board[i].length; i += step1, j += step2) {\r\n        if (board[i][j].markerType !== markerType)\r\n            return count;\r\n        count++;\r\n    }\r\n\r\n    return count;\r\n}\r\n\r\nfunction countRowSequentCells(row: ICell[], currentIndex: number): number {\r\n    return 1 + countRowSideSequentCells(row, currentIndex, -1) + countRowSideSequentCells(row, currentIndex, 1);\r\n}\r\n\r\nfunction countColumnSequentCells(board: ICell[][], currentRowIndex: number, currentColumnIndex: number): number {\r\n    return 1 + countColumnSideSequentCells(board, currentRowIndex, currentColumnIndex, -1) + countColumnSideSequentCells(board, currentRowIndex, currentColumnIndex, 1);\r\n}\r\n\r\nfunction countRightDiagonalSequentCells(board: ICell[][], currentRowIndex: number, currentColumnIndex: number): number {\r\n    return 1 + countDiagonalSideSequentCells(board, currentRowIndex, currentColumnIndex, -1, 1) + countDiagonalSideSequentCells(board, currentRowIndex, currentColumnIndex, 1, -1);\r\n}\r\n\r\nfunction countLeftDiagonalSequentCells(board: ICell[][], currentRowIndex: number, currentColumnIndex: number): number {\r\n    return 1 + countDiagonalSideSequentCells(board, currentRowIndex, currentColumnIndex, -1, -1) + countDiagonalSideSequentCells(board, currentRowIndex, currentColumnIndex, 1, 1);\r\n}\r\n\r\nfunction isWinningSequence(state: IState, rowIndex: number, columnIndex: number): boolean {\r\n    const board = state.board;\r\n    const winningSequenceLength = state.gameConfiguration.winningSequenceLength;\r\n\r\n    return countRowSequentCells(board[rowIndex], columnIndex) >= winningSequenceLength ||\r\n        countColumnSequentCells(board, rowIndex, columnIndex) >= winningSequenceLength ||\r\n        countRightDiagonalSequentCells(board, rowIndex, columnIndex) >= winningSequenceLength ||\r\n        countLeftDiagonalSequentCells(board, rowIndex, columnIndex) >= winningSequenceLength;\r\n}\r\n\r\nfunction markCell(state: IState, rowIndex: number, columnIndex: number): void {\r\n    if (state.isWinner)\r\n        return;\r\n\r\n    const currentCell = state.board[rowIndex][columnIndex];\r\n\r\n    if (currentCell.markerType != null)\r\n        return;\r\n\r\n    currentCell.markerType = state.currentTurnMarkerType;\r\n\r\n    if (isWinningSequence(state, currentCell.rowIndex, currentCell.columnIndex)) {\r\n        state.isWinner = true;\r\n    } else {\r\n        state.currentTurnMarkerType = state.currentTurnMarkerType === MarkerType.cross\r\n            ? MarkerType.zero\r\n            : MarkerType.cross;\r\n    }\r\n}\r\n\r\nfunction createState(gameMode: GameMode): IState {\r\n    return {\r\n        board: createBoard(gameMode),\r\n        currentTurnMarkerType: MarkerType.cross,\r\n        isWinner: false,\r\n        currentGameMode: gameMode,\r\n        gameConfiguration: getGameConfiguration(gameMode)\r\n    }\r\n}\r\n\r\nfunction copyBoard(board: ICell[][]): ICell[][] {\r\n    return board.map(row => row.map(cell => cell));\r\n}\r\n\r\ntype Action = ReturnType<typeof createMarkCellAction | typeof createRestartGameAction | typeof createChangeGameAction>;\r\n\r\nexport const rootReducer = (state: IState = initialState, action: Action): IState => {\r\n    switch (action.type) {\r\n        case markCellActionType: {\r\n            const newBoard = copyBoard(state.board);\r\n            const newState = {...state, board: newBoard};\r\n            markCell(newState, action.payload.rowIndex, action.payload.columnIndex);\r\n\r\n            return newState;\r\n        }\r\n\r\n        case restartGameActionType: {\r\n            const newState = createState(state.currentGameMode);\r\n\r\n            return newState;\r\n        }\r\n\r\n        case changeGameActionType: {\r\n            const newState = createState(action.payload.gameMode);\r\n\r\n            return newState;\r\n        }\r\n    }\r\n    return state;\r\n};","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport {Provider} from \"react-redux\";\nimport {createStore} from \"redux\";\nimport {rootReducer} from \"./redux/rootReducer\";\n\nconst store = createStore(rootReducer);\n\nReactDOM.render(\n    <Provider store={store}>\n        <App/>\n    </Provider>,\n    document.getElementById('root')\n);"],"sourceRoot":""}